<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head>
  <title>DSL Lecture 4</title>

  
  
  <link rel="stylesheet" href="PS_Lecture.css">

</head><body>
<!-- Site navigation menu -->
<ul class="navbar">

  <li><a href="PS_DSL_Syllabus.html">Syllabus</a></li>
  <li><a href="PS_DSL_Lecture_01.html">Lecture 1</a></li>
  <li><a href="PS_DSL_Lecture_02.html">Lecture 2</a></li>
  <li><a href="PS_DSL_Lecture_03.html">Lecture 3</a></li>
  <li><a href="PS_DSL_Lecture_05.html">Lecture 5</a></li>
  <li><a href="PS_DSL_Lecture_06.html">Lecture 6</a></li>
  <li><a href="PS_DSL_Lecture_07.html">Lecture 7</a></li>
  <li><a href="PS_DSL_Lecture_08.html">Lecture 8</a></li>
  <li><a href="PS_DSL_Lecture_09.html">Lecture 9</a></li>
  <li><a href="PS_DSL_Lecture_10.html">Lecture 10</a></li>
</ul>

<!-- Main content -->
<h1>Penn State Great Valley<br>
DSL Course - Lecture 4</h1>

<img style="width: 600px; height: 391px;" alt="aurora" src="images/aurora/aurora/aurora-borealis-over-snow-covered-road-600w.jpg"><br>

<br>

<h2>Implementing External DSLs</h2>

Implementing an external DSL differs
from internal DSLs in that the parsing process operates on pure text
input which is not constrained by any particular language.
&nbsp;The
techniques we can use to parse text are essentially those that have
been in use for decades in parsing programming languages.
&nbsp;There
is also a long-running language community developing these tools and
techniques.<br>

<br>

But there is a catch. &nbsp;The tools and writings
of the programming language community almost always assume your are
working with a general-purpose language. &nbsp;DSLs are lucky to
get
mention in passing. &nbsp;While many of the principles apply
equally to
general-purpose and domain-specific languages, there are differences.
&nbsp;In addition, you don't need to go all the way up the learning
curve that you'd need to go for a general-purpose language.
<h2>An example<br>
<span style="text-decoration: underline;"></span></h2>

The simplest way is to devide the input text into lines then process
each line. &nbsp;As an example let's use the well worn DSL known as
<span style="font-style: italic; font-weight: bold;">make</span>.
&nbsp;You need a file called a makefile to tell <span style="font-weight: bold; font-style: italic;">make</span>
what to do. &nbsp;Most often, the makefile tells <span style="font-weight: bold; font-style: italic;">make</span>
how to compile and link a program, most famously&nbsp;in C or C++.
&nbsp;Let's say we have a simple makefile that describes how to
compile and link a text editor which consists of eight C source files
and three header files. &nbsp;The makefile can also tell <span style="font-weight: bold; font-style: italic;">make</span>
how to run miscellaneous commands when explicitly asked, for example,
to remove certain files as a clean-up operation.<br>

<br>

When <span style="font-weight: bold; font-style: italic;">make</span>
recomples the editor, each changed C source file must be recompiled.
&nbsp;If a header file has changed, each C source file that
includes the header must be recompiled to be safe. &nbsp;Each
compilation produces an object file corresponding to the source file.
&nbsp;Finally, if any source file has been recompiled, all the
object files, whether newly made or saved from previous compilations,
must be linked together to produce the new executable editor.<br>

<br>

The text above represents the "domain" of <span style="font-weight: bold; font-style: italic;">make</span>.
In there are all the nouns and verbs needed to determine what our
syntax will be. &nbsp;Mostly <span style="font-weight: bold; font-style: italic;">make</span>
is about dependencies and rules. &nbsp;A simple makefile consists
of rules with the following shape:<br>

<br>

<span class="code"><br>
target ... : dependencies ...<br>
&nbsp;&nbsp;command<br>
&nbsp;&nbsp;...<br>
&nbsp;&nbsp;...<br>
</span><br>

A target is usually the name of a file that is generated by a program;
examples of targets are executable or object files. &nbsp;A target
can also be the name of an action to carry out, such as clean. &nbsp;A
subset of target is a goal. &nbsp;Goals are targets that <span style="font-weight: bold; font-style: italic;">make</span><span style="font-weight: bold; font-style: italic;"> </span>strives
ultimately to update.<br>

<br>

A dependency is a file that is used as input to a create the target.
&nbsp;A target depends on several files.<br>

<br>

A command is an action that make carries out. &nbsp;A rule may have
more than one command, each on its own line. &nbsp;With <span style="font-weight: bold; font-style: italic;">make&nbsp;</span>
you need to put a tab character at the beginning of every command line!
&nbsp;<span style="color: white;">So it is important
to understand that when it comes to&nbsp;syntax those
items&nbsp;which you cannot see may be just as important as those
you can see!! <br>
</span><br>

Usually a command is in a rule with dependencies and serves to create a
target file if any of teh dependencies change. &nbsp;However, the
rul that specifies commands for the target need not have dependencies.
&nbsp;For example, the rule containing the delete command
associated with the target 'clean' does not have dependencies.<br>

<br>

Lastly a rule explains how and when to remake certain fiels which are
the targets of the particular rule. &nbsp;<span style="font-weight: bold; font-style: italic;">make </span>carries
out the commands on the dependencies to create or update the target.
&nbsp;A rule can also explain how and when to carry out an action.<br>

<br>

An example is in order:<br>

<br>

<br>

<br>

<span class="code">&nbsp;edit : main.o kbd.o command.o display.o \<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
insert.o search.o files.o utils.o<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cc -o edit main.o kbd.o command.o display.o \<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
insert.o search.o files.o utils.o<br>
&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp; main.o : main.c defs.h<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cc -c main.c<br>
&nbsp;&nbsp;&nbsp;&nbsp; kbd.o : kbd.c defs.h command.h<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cc -c kbd.c<br>
&nbsp;&nbsp;&nbsp;&nbsp; command.o : command.c defs.h
command.h<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cc -c command.c<br>
&nbsp;&nbsp;&nbsp;&nbsp; display.o : display.c defs.h
buffer.h<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cc -c display.c<br>
&nbsp;&nbsp;&nbsp;&nbsp; insert.o : insert.c defs.h
buffer.h<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cc -c insert.c<br>
&nbsp;&nbsp;&nbsp;&nbsp; search.o : search.c defs.h
buffer.h<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cc -c search.c<br>
&nbsp;&nbsp;&nbsp;&nbsp; files.o : files.c defs.h
buffer.h command.h<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cc -c files.c<br>
&nbsp;&nbsp;&nbsp;&nbsp; utils.o : utils.c defs.h<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cc -c utils.c<br>
&nbsp;&nbsp;&nbsp;&nbsp; clean :<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rm edit main.o kbd.o command.o display.o \<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
insert.o search.o files.o utils.o<br>
<br>
</span>
A long line is split into two line using the backslash-newline; this is
like using one long line, but easier to read.<br>

<br>

To use this makefile to delete the executable fiel and all the object
files from the directory, type:<br>

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="font-style: italic;"><span style="font-weight: bold;">make clean</span></span><br>

<br>

In
the example makefile, the targets include the executable file 'edit',
and the object files 'main.o', and 'kbd.o'. &nbsp;The dependencies are
files such as 'main.c' and 'defs.h'. &nbsp;In fact, each ' .o' file is
both a target and a dependency. &nbsp;Command include 'cc -c main.c'
and 'cc -c kbd.c'.<br>

<br>

When a target is a file, it needs to be
recompiled or relinked if any of its dependencies change. &nbsp;In
addition, any dependencies that are themselves &nbsp;automatically
generated should be updated first. &nbsp;In this example, 'edit'
depends on each of the eight object files; the object file 'main.o'
depends on the source file 'main.c' and on the header file 'defs.h'.<br>

<br>

The
target 'clean' is not a file, but merely the name of an action.
&nbsp;Since you normally do not want to carry out the actions in this
rule, 'clean' is not a dependency of any other rule.
&nbsp;Consequently, <span style="font-weight: bold; font-style: italic;">make</span> never
does anything with it unless you tell it specifically. &nbsp;Note that
this rule not only is not a dependency, it also does not have any
dependencies, so the only purpose of the rule is to run the specified
commands. &nbsp;Targets that do not refer to files but are just actions
are called <span style="font-style: italic;">phoney targets</span>.<br>

<br>

<h4>How <span style="font-style: italic;">make</span> Process a
Makefile</h4>

By default, <span style="font-weight: bold; font-style: italic;">make</span><span style="font-weight: bold; font-style: italic;">&nbsp; </span>starts
with the first target (not targets whose names start with '.').
&nbsp;This is called the default goal. In the example, the default goal
is to update the executable program 'edit'; therefore, we put that rule
first.<br>

<br>

Thus when you give the command:<br>

<br>

&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="font-weight: bold; font-style: italic;">make</span><br>

<span style="font-weight: bold; font-style: italic;"></span><br>

<span style="font-weight: bold; font-style: italic;">make</span><span style="font-weight: bold; font-style: italic;"> </span>reads
the makefile in the current directory and begins by processing the
first rule. &nbsp;In the example, this rule is for relinking 'edit';
but before <span style="font-weight: bold; font-style: italic;">make</span>
can fully process this rule, it must process the rules for the files
that 'edit' depends upon, which in this case are the object files.
&nbsp;Each of these files is processed according to its own rule.
&nbsp;These rules say to update each ' .o' file by compiling its source
file. &nbsp;The recompilation must be done if the source file, or any
of the header files named as dependencies, is more recent than the
object file, or if the object file does not exist.<br>

<br>

The other
rules are processed because their targets appear as dependencies of the
goal. &nbsp;If some other rule is not depended on by the goal, that
rule is not processed, unless you tell <span style="font-weight: bold; font-style: italic;">make</span> to do so
with a command such as <span style="font-weight: bold; font-style: italic;">make clean.</span><br>

<br>

Before recompiling an object file, <span style="font-weight: bold; font-style: italic;">make&nbsp;</span>
considers updating its dependencies, the source file and header files.
&nbsp;This makefile does not specify anything to be done for them - the
' .c' and &nbsp;' .h' files are not the targets of any rules so <span style="font-weight: bold; font-style: italic;">make</span> does
nothing for these files.<br>

<br>

After recompiling whichever object files need it, <span style="font-weight: bold; font-style: italic;">make</span>&nbsp;<span style="font-weight: bold; font-style: italic;"></span>decides
whether to relink 'edit'. &nbsp;This must be done if the file 'edit'
does not exist, or if any of the object files are newer than it.
&nbsp;If an object file was just recompiled, it is now newer than
'edit', so 'edit' is relinked.<br>

<br>

This if we change the file 'insert.c' and run <span style="font-weight: bold; font-style: italic;">make,</span> <span style="font-weight: bold; font-style: italic;">make</span> will
compile that file to update 'insert.o' and then link 'edit'. &nbsp;If
we change the file 'command.h' and run <span style="font-weight: bold; font-style: italic;">make, </span><span style="font-weight: bold; font-style: italic;">make </span>will
recompile the object files 'kbd.o', 'command.o' and 'files.o' and then
link the file 'edit'.<br>

<span style="font-weight: bold; font-style: italic;"></span>
<h2><span style="text-decoration: underline;">Syntactic
Analysis
Strategy</span></h2>

What you should be seeing from this example is that each line in our
make files tells us something specific in our DSL. &nbsp;<span style="font-weight: bold; font-style: italic;">edit : </span>&nbsp;is
a definition of a target and to exact our goal target. &nbsp;Syntactic
analysis is about recognizing the different parts of our DSL and
creating actions from those parts. &nbsp;Initially
we must parse an external DSL. &nbsp;We need to take the stream of
text
and break it up into some kind of structure that we can use to figure
out what that text says. &nbsp;This initial structuring is referred
to
as syntactic analysis.<br>

<span style="color: white;"></span>
<h2>Let's start simple!</h2>

The simplest way to do syntactic analysis
is something you have probably all done. &nbsp;Divide the input text
into lines, then process each line. &nbsp;With <span style="font-weight: bold; font-style: italic;">make</span>
you know that if it starts with a tab then you are dealing with a
command. &nbsp;You then break up the line accordingly to find the key
bits of information. &nbsp;This style is referred by Fowler as
Delimiter-Directed Translation. &nbsp;The general idea is to pick some
delimiter characters that break the input into statements (usually line
endings), chop the input into separate statements using that delimiter,
and then feed each chunk into a separate processing step to figure out
what's on the line. &nbsp;Usually, there's some clear marker in the
line that tells you what kind of statement you are dealing with.<br>
<br>
Delimiter-Directed Translation is very simple to use and uses tools
that most programmers are familiar with - string splitting and regular
expressions.&nbsp; Its limitation is that it doesn't give you any
inherent way to handle the hierarchic context of your input.<br>
<br>
From the example above you can see that 'edit' depends on 'main.0'
which depends on 'main.c', so you can see there is a rudimentary
hierarchy building here.&nbsp; Complex makefiles have complex
hierarchies.<br>
<br>
In order to handle DSLs with more complex structures we use a technique
called Syntax-Directed Translation.&nbsp; In this technique, we first
define a formal grammar for the input language.&nbsp; For our example,
it would look something like this:<br>
<br>
<br>


<span class="code"><br>
target ... : dependencies ...<br>
&nbsp;&nbsp;command<br>
&nbsp;&nbsp;...<br>
&nbsp;&nbsp;...<br>
</span><br>
Looks familiar right!&nbsp; It should this is call the Backus-Naur Form
or BNF.&nbsp; It is a way of writing grammarys to define the syntax of
a language.&nbsp; It was invented to describe Algol in 60s and since
then it has been widely used&nbsp; for both explanation and to drive
Syntx-Directed Translation.<br>
<br>
In BNF, each line is a production rule; it states a name followed by the legal elements of that rule.&nbsp; <br>
<br>

The simplest of options that you have when designing an external DSL is
when you have a custom syntax that you've developed a parser
for.&nbsp;
The parsing engine first lexicalizes the input stream, converting them
to recognizable tokens.&nbsp; These tokens are also known as the
terminals of the grammar.&nbsp; The tokens are then fed on to the
production rules and parsed as valid sentences of the grammar.<br>

<br>

The parsing infrastructure is the only processor that does everything
required to process the input DSL script and generate the necessary
output.<br>

<br>

<br>

<br>

<br>

<br>

<p>A
language is just a set of valid sentences. &nbsp;Every language
appllication will have a parser (recognizer) component. &nbsp;The
whole
point to writing a grammar or Semantic Model is so you
can&nbsp;build a
programthat recognizes sentences in that language. </p>

<p>Language
applications can be complicated and with anything complicated we want
to break them down into bite-size chuncks. &nbsp;The goal is to get
the
components to fit together in a multistage pipeline that analyzes or
manipulates an input stream. &nbsp;The pipeline gradually converts
an
input sentence (valid input sentence) to a handy internal data
structure or translates it to a sentence in another language.</p>

<img style="width: 779px; height: 223px;" alt="Multi-stage Pipeline" src="images/Pipeline.jpg">
<p>The
basic idea is the reader recognizes the input and builds an
intermediate representation (IR) that feeds the rest of the
application. &nbsp;The intermedeiate stages form the semantic
analyzer
which figures out what the input means. &nbsp;At the end, a
generator
emits output based upon the IR and what the application learned in the
intermediate stages.</p>

<p>There are four broad application catagories to the pipeline
described above:</p>

<ol>

  <li>Reader
- A reader builds a data structure from one or more input streams.
&nbsp;The input streams are usually text but can be binary data as
well. &nbsp;Examples include configuration file readers, program
analysis tools such as a method cross-reference tool, and class file
loaders.</li>
  <li>Generator - A generator walks an internal data
structure and emits output. &nbsp;Examples include
object-to-relational
database mapping tools, object serializers, source code generators, and
web page generators.</li>
  <li>Translator or Rewriter - A translator
reads text or binary input and emits output conforming to the same or a
different language. &nbsp;It is essentially a combined reader and
generator. &nbsp;Examples include translators from extinct
programming
languages to modern languages, wiki to HTML translators, refactorers,
profilers that instrument code, log file report generators, pretty
printers, and macro preprocessors. &nbsp;Some translators, such as
assemblers and compilers, are so common that they warrant their own
subcategories.</li>
  <li>Interpreter - An interpreter reads, decodes, and
executes instructions. &nbsp;Interpreters range from simple
calculators
and POP protocol servers all the way up to programming language
implementations such as those for Java, Ruby, and Python.</li>
</ol>

<h3>Parsing Input Sentences - Readers</h3>

The most basic reader component and probably something most of you have
already done in some form, most likely with XML. &nbsp;So here are
a couple of short examples with of parsing an XML file with Python.<br>

<br>

This example uses Document object model:<br>

<br>

<code><br>
&nbsp;&nbsp;from xml.dom import minidom, Node<br>
&nbsp;&nbsp;def scanNode(node, level = 0):<br>
&nbsp;&nbsp;&nbsp;&nbsp;msg = node.__class__.__name__<br>
&nbsp;&nbsp;&nbsp;&nbsp;if node.nodeType ==
Node.ELEMENT_NODE:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg += ",
tag: " + node.tagName<br>
&nbsp;&nbsp;&nbsp;&nbsp;print(" " * level * 4, msg)<br>
&nbsp;&nbsp;&nbsp;&nbsp;if node.hasChildNodes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for child
in node.childNodes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scanNode(child,
level + 1)<br>
<br>
&nbsp;&nbsp;doc = minidom.parse('planets.xml')<br>
&nbsp;&nbsp;scanNode(doc)<br>
</code><br>

This example uses tree structure:
<code><br>
<br>
&nbsp;&nbsp;from xml.etree import ElementTree as etree<br>
<br>
&nbsp;&nbsp;def main():<br>
&nbsp;&nbsp;&nbsp;&nbsp;tree =
etree.<span style="font-weight: bold;">parse</span>("planets.xml")<br>
&nbsp;&nbsp;&nbsp;&nbsp;root = tree.getroot()<br>
&nbsp;&nbsp;&nbsp;&nbsp;print("root: ")<br>
&nbsp;&nbsp;&nbsp;&nbsp;print(root)<br>
&nbsp;&nbsp;&nbsp;&nbsp;for child in root:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("
child: ")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(child)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for
grandchild in child:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("
grandchild: ")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(grandchild)<br>
<br>
&nbsp;&nbsp;if __name__ == "__main__":<br>
&nbsp;&nbsp;&nbsp;&nbsp;# Someone is launching this
directly<br>
&nbsp;&nbsp;&nbsp;&nbsp;main()<br>
</code>
<br>

<br>

<h3>Generating Sentences with State Machines</h3>

<h3>The Requirements for Generating Complex Language</h3>

<br>

<br>

<h3>Enforcing Sentence Tree Structure with Pushdown Machines</h3>

<h3>Ambiguous Languages</h3>

<br>

<h3>Vocabulary Symbols Are Structured Too</h3>

<h3>Recognizing Computer Language Sentences</h3>

<br>

<p>A generic template for displaying HTML for a lecture!
</p>

<p>It lacks images, but at least it has style.
And it has links, even if they don't go
anywhere&#8230;
</p>

<p><code>int x = rand()*17;</code>
</p>

<p>There should be more here, but I don't know
what yet.
<!-- Sign and date the page, it's only polite! --></p>

<address>Made 31 August 2011<br>
by D Bartlett.</address>

=
</body></html>